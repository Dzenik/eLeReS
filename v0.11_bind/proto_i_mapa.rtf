{\rtf1\ansi\ansicpg1250\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww20880\viewh10120\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 mapa EEPROM (wspolna dla TX i RX):\
------------------------------------------------------\
\
\
offset   dlugosc     nazwa                                          opis\
0           4B	             RF_HEADER                             wartosci naglowka - bindowanie (4 bajty pokazywane w konfiguratorze HEX'em) - moze byc edytowane\
4	    1B             TX_POWER                               moc nadajnika: wartosci 0..7. gdzie w konfiguratorze dropdowna ma miec podane moce (zeby user widzial moce, a nie numerek)\
5           4B             CARRIER_FREQUENCY	czestotliwosc w kHz (do wpisania z zakresu 433000 .. 450000). Prezentowac to nalezy tak np: "433,200" i obok napis "MHz"\
\
\
Chwilowo to wszystko, ale myse, ze mozesz spodziewac sie kolejnych pozycji w mapie.\
Narazie pokazemy ludziom to. I sie posraja ;)\
\
\
\
Protokol transmisyjny:\
--------------------------------\
Identyfikatory pakietow:\
#define UART_CMD_EEPROM_DATA	'w'\
#define UART_CMD_EEPROM_END		'e'\
#define UART_CMD_EEPROM_REQ		'r'\
#define UART_CMD_ERROR			'x'\
#define UART_CMD_OK				's'\
#define UART_CMD_PING			'p'\
#define UART_CMD_VERSION		'i'\
#define UART_CMD_DEBUG_MESSAGE	'm'	\
#define UART_CMD_RSSI			'a'\
#define UART_EOT				'#'\
\
\
EEPROM zostaje po staremu - czyli czytanie i pisanie do eepromu (paczkowanie, itp) podlega tym samym regulom.\
Zmienily sie tylko identyfikatory pakietow.\
\
PING i VERSION tez jest po staremu (wypadaloby zapingowac, zeby odczytac wersje urzadzenia).\
\
\
Doszlo natomiast RSSI:\
-----------------------------------\
To jest podzielona na 4 paczki tablica 0..255 zawierajaca moce dla poszczegolnych kanalow.\
[a][nr_paczki][tablica z danymi][CRC]#   <- i tak jak zwykle\'85wnetrzne pociagniete base64\
nr_paczki to 1B\
tablica z danymi to - char rssi[64]\
\
I teraz\'85..\
Bedziesz mial u siebie bufor 0..255, w ktorym bedziesz trzymal wartosci RSSI dla poszczegolnego kanalu (256 kanalow - wiadomo).\
Musisz ten bufor narysowac na ekranie - i odswiezac go w interwale np 50-100ms (nie ma znaczenia).\
Ten bufor z danymi bedzie uzupelniany w takt otrzymywania powyzszych paczek.\
Jesli dostaniesz paczke o numerze 0, to wypelniasz bufor 64 bajtami zaczynajac od indexu = 0.\
Jak dostaniesz paczke o numerze 1, to wypelniasz bufor 64 bajtami, ale zaczynajac od indexu=64.\
Jak paczka = 2, to wypelniasz zaczynajac od indexu 128\
a jak paczka = 3\'85., to od indexu 192 do konca\
\
Na paczki podzielilem, bo mi sie tak duzy bufor danych w pamieci procka nie zmiesci.\
Niech to jakos fajnie wyglada\'85. i spodziewaj sie, ze w nastepnej wersji bedzie trzeba wyskalowac wykres. (ale poki co nie dotykaj tematu!\'85bo szkoda roboty)\
Czyli\'85 ekranik z podgladem widma sygnalu powinien na osi poziomej miec czestotliwosci, a w osi pionowej amplitude. \
Kazdy kolejny index bufora rssi, to kolejna czestotliwosci. Wiec rysujesz slupek o odpowiedniej wysokosci. Zielone, na czarnym tle. Dodatkowo\'85niech to bedzie szersze niz wyzsze (zebys kwadratu tam czasem nie zrobil:) )\
\
\
si?\
\
\
\
\
\
}